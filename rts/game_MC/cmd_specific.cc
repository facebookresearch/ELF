/**
* Copyright (c) 2017-present, Facebook, Inc.
* All rights reserved.

* This source code is licensed under the BSD-style license found in the
* LICENSE file in the root directory of this source tree.
*/

#include "engine/cmd.h"
#include "engine/game_env.h"
#include "engine/cmd_receiver.h"

// Derived class. Note that the definition is automatically generated by a python file.
#include "engine/cmd.gen.h"
#include "engine/cmd_specific.gen.h"
#include "cmd_specific.gen.h"

bool CmdGenerateMap::run(GameEnv *env, CmdReceiver*) {
   // std::cout<<"CmdGenerateMap"<<std::endl;
    return env->GenerateMap(_num_obstacles, _init_resource) ? true : false;
}

#define _CREATE(...) receiver->SendCmd(CmdIPtr(new CmdCreate(INVALID, __VA_ARGS__)))
#define _CHANGE_RES(...) receiver->SendCmd(CmdIPtr(new CmdChangePlayerResource(INVALID, __VA_ARGS__)))


bool CmdGameStartSpecific::run(GameEnv*, CmdReceiver* receiver) {
   // std::cout<<"CmdGameStartSpecific"<<std::endl;
    const PlayerId player_id = 0;
    const PlayerId enemy_id = 1;
    _CREATE(RESOURCE, PointF(2, 1), player_id);
    _CREATE(WORKER, PointF(4, 4), player_id);
    _CREATE(WORKER, PointF(5, 5), player_id);
    _CREATE(WORKER, PointF(6, 7), player_id);
    //_CREATE(RANGE_ATTACKER, PointF(15, 18), player_id);
    _CREATE(BASE, PointF(7, 2), player_id);
    //_CREATE(BARRACKS, PointF(8, 5), player_id);
    _CHANGE_RES(player_id, 100);

    _CREATE(BASE, PointF(18, 16), enemy_id);
    //_CREATE(WORKER, PointF(17, 15), enemy_id);
    //_CREATE(WORKER, PointF(18, 15), enemy_id);
    //_CREATE(WORKER, PointF(19, 16), enemy_id);
    _CREATE(RESOURCE, PointF(14, 18), enemy_id);
    //_CREATE(RANGE_ATTACKER, PointF(12, 11), enemy_id);
    _CHANGE_RES(enemy_id, 100);

    return true;
}


// 创建雷达并设置朝向
bool CreateRadar(Tick _tick,GameEnv* env,PlayerId player_id,PointF radar_p,PointF towards,int round){
   UnitId radar_id = -1;
   if(! env->AddUnit(_tick, RANGE_ATTACKER, radar_p, player_id,radar_id)){
        std::cout<<"create radar failed at "<<radar_p<<std::endl;
        return false;
    }
   Unit* radar = env->GetUnit(radar_id);
   if(radar == nullptr) return false; //雷达创建失败
   //设置雷达朝向
   radar->GetProperty().towards.x = towards.x;
   radar->GetProperty().towards.y = towards.y;
   radar->GetProperty().round = round;  //设置雷达的索敌数量
   //std::cout<<"Create Radar at "<<radar->GetPointF()<<" towards "<<radar->GetProperty().towards<<std::endl;
   return true;
}

// 创建飞机
// 飞机位置、攻击类型、出发时刻(tick)
bool CreateFlight(Tick _tick,GameEnv* env,PlayerId player_id,PointF flight_p,FlightType flight_t,Tick _start_tick){
    UnitId flight_id = -1;
    if(! env->AddUnit(_tick, WORKER, flight_p, player_id,flight_id)){
        //std::cout<<"create flighter failed at "<<flight_p<<std::endl;
        return false;
    }
    Unit* flight = env->GetUnit(flight_id);
    if(flight == nullptr) return false; //飞机创建失败
    // 设置飞机属性
    flight->GetProperty().flight_state = FLIGHT_IDLE; // 设置飞行状态为待机
    flight->GetProperty().flight_type = flight_t; // 设置飞机类型
    flight->GetProperty().start_tick = _start_tick; // 设置入场时间
    //std::cout<<"Create Flighter start at "<<flight_p<<" tick_: "<<_start_tick<<std::endl; 
    return true;
}

// 随机生成飞机的座标
/**
 * left up right down 飞机生成区域边界
 * **/
PointF GetStartPoint(GameEnv *env,int left,int right, int up, int down){
        auto f = env->GetRandomFunc();
        int _x = 0,_y = 0;

        int incoming = f(2);  // 飞机生成方向 0 - 上边界 1 - 左边界  2 - 右边界
        switch (incoming)
        {
        case 0:  // 上
            _x = f(right-left+1)+left;
            _y = up;
            break;
        case 1:  // 右边
            _x = right;
            _y = f(down - up+1) + up;
        case 2:  // 左边
            _x = left;
            _y = f(down - up+1) + up;
        default:
            break;
        }

       
        return PointF(_x,_y);
    }

// 随机生成出发时间
Tick GetStartTick(GameEnv *env,Tick start,Tick end){
    auto f = env->GetRandomFunc();
    return start + f(end - start);
}

bool CmdGenerateUnit::run(GameEnv *env, CmdReceiver *receiver) {
    //std::cout<<"CmdGenerateTDUnit"<<std::endl;
    const PlayerId player_id = 0;
    const PlayerId enemy_id = 1;
    // 保护目标
    _CREATE(BASE, PointF(35, 35), player_id);
    /**
     *   if (! build_p.IsInvalid()) {
                   // 创造导弹 
                   UnitId rocket_id;
                   
                   if (! env_temp.AddUnit(_tick, BARRACKS, build_p, u->GetPlayerId(),rocket_id)) {
                        std::cout<<"emit rocket failed"<<std::endl;
                        return false;
                    }
                    //载弹量 -1
                    --env_temp.GetUnit(_id)->GetProperty().round;
                    // 发射导弹(让导弹去攻击目标)
                    receiver->SendCmd(CmdBPtr(new CmdAttack(rocket_id, _target)));
                    _done = true;
                }
     * **/
    // 雷达
    PointF radar_1_p = PointF(36,34.8); //雷达1位置
    PointF radar_2_p = PointF(34,34.8); //雷达2位置
    if(!CreateRadar(_tick,env,player_id,radar_1_p,PointF(1,-1.732),8)) return false;   // 生成雷达并设置朝相
   
    if(!CreateRadar(_tick,env,player_id,radar_2_p,PointF(-1,-1.732),8)) return false;  // 生成雷达并设置朝向
    
    //_CREATE(WORKER,PointF(20,20),player_id);
    
    
    // 炮台
    // B1
    _CREATE(MELEE_ATTACKER,PointF(29.0122,34.4522),player_id);
    _CREATE(MELEE_ATTACKER,PointF(29.30155,33.0899),player_id);
    _CREATE(MELEE_ATTACKER,PointF(29.9549,31.86105),player_id);
    _CREATE(MELEE_ATTACKER,PointF(30.9217,30.85995),player_id);
    _CREATE(MELEE_ATTACKER,PointF(32.12695,30.1641),player_id);
    _CREATE(MELEE_ATTACKER,PointF(33.47735,29.8274),player_id);
    _CREATE(MELEE_ATTACKER,PointF(34.86825,29.87595),player_id);
    _CREATE(MELEE_ATTACKER,PointF(36.19185,30.30605),player_id);

    // // B2
    _CREATE(MELEE_ATTACKER,PointF(40.9878,34.4522),player_id);
    _CREATE(MELEE_ATTACKER,PointF(40.69845,33.0899),player_id);
    _CREATE(MELEE_ATTACKER,PointF(40.0451,31.86105),player_id);
    _CREATE(MELEE_ATTACKER,PointF(39.0783,30.85995),player_id);
    _CREATE(MELEE_ATTACKER,PointF(37.87305,30.1641),player_id);
    _CREATE(MELEE_ATTACKER,PointF(36.52265,29.8274),player_id);
    _CREATE(MELEE_ATTACKER,PointF(35.13175,29.87595),player_id);
    _CREATE(MELEE_ATTACKER,PointF(33.80815,30.30605),player_id);

    //std::cout<<"radius: "<<PointF::L2Sqr(PointF(40.9878,34.4522),PointF(35,35))<<std::endl;


   

    _CHANGE_RES(player_id, 100);  // 给一个初始资源



   

    // enemy
    
    // _CREATE(WORKER,PointF(30,10),enemy_id);
    // _CREATE(WORKER,PointF(40,10),enemy_id);

    // _CREATE(WORKER,PointF(1,1),enemy_id);
    // _CREATE(WORKER,PointF(34,1),enemy_id);
    // _CREATE(WORKER,PointF(36,1),enemy_id);
    // _CREATE(WORKER,PointF(68,1),enemy_id);
    //_CREATE(BASE,PointF(1,1),enemy_id);

    // Test 生成飞机的位置
    // PointF flight_1_p,flight_2_p,flight_3_p,flight_4_p; 
    

   

    
    // 随机生成飞机的位置
    //第一轮： 无差别攻击 4NORMAL
    Tick first_round = GetStartTick(env,10,50);
    while(true){
       if(CreateFlight(_tick,env,enemy_id, GetStartPoint(env,2,68,2,24),FLIGHT_NORMAL,first_round)) break;
    }

    while(true){
       if(CreateFlight(_tick,env,enemy_id, GetStartPoint(env,2,68,2,24),FLIGHT_NORMAL,first_round)) break;
    }

    while(true){
       if(CreateFlight(_tick,env,enemy_id, GetStartPoint(env,2,68,2,24),FLIGHT_NORMAL,first_round)) break;
    }

    while(true){
       if(CreateFlight(_tick,env,enemy_id, GetStartPoint(env,2,68,2,24),FLIGHT_NORMAL,first_round)) break;
    }
    

    // 第二轮： 攻击防御目标 3BASE 1 Normal
    Tick second_round =GetStartTick(env,1000,1050);

     while(true){
       if(CreateFlight(_tick,env,enemy_id, GetStartPoint(env,1,69,1,25),FLIGHT_BASE,second_round )) break;
    }

    while(true){
       if(CreateFlight(_tick,env,enemy_id, GetStartPoint(env,1,69,1,25),FLIGHT_BASE,second_round )) break;
    }

    while(true){
       if(CreateFlight(_tick,env,enemy_id, GetStartPoint(env,1,69,1,25),FLIGHT_BASE,second_round )) break;
    }

    while(true){
       if(CreateFlight(_tick,env,enemy_id, GetStartPoint(env,1,69,1,25),FLIGHT_NORMAL,second_round )) break;
    }

    
    
    
    
    return true;
}

//-----------------Test--------------------
// bool CmdGenerateUnit::r  un(GameEnv *env, CmdReceiver *receiver) {
//    // std::cout<<"CmdGenerateUnit"<<std::endl;
//     auto f = env->GetRandomFunc();
//     int lr_seed = f(2);
//     int ud_seed = f(2);
//     bool shuffle_lr = (lr_seed == 0);
//     bool shuffle_ud = (ud_seed == 0);
//     auto shuffle_loc = [&] (PointF p, bool b1, bool b2) -> PointF {
//         int x = b1 ? 19 - p.x : p.x;
//         int y = b2 ? 19 - p.y : p.y;
//         return PointF(x, y);
//     };

//     receiver->GetGameStats().PickBase(lr_seed * 2 + ud_seed);
//     for (const auto &info : env->GetMap().GetPlayerMapInfo()) {
//         PlayerId id = info.player_id;
//         _CREATE(BASE, shuffle_loc(PointF(info.base_coord), shuffle_lr, shuffle_ud), id);
//         _CREATE(RESOURCE, shuffle_loc(PointF(info.resource_coord), shuffle_lr, shuffle_ud), id);
//         _CHANGE_RES(id, info.initial_resource);
//         //base_locs[id] = PointF(info.base_coord);
//     }
//     // for (size_t i = 0; i < base_locs.size(); ++i) {
//     //    std::cout << "[" << i << "] Baseloc: " << base_locs[i].x << ", " << base_locs[i].y << std::endl;
//     //}
//     auto gen_loc = [&] (int player_id) -> PointF {
//         // Note that we could not write
//         //    PointF( f(8) + ...,  f(8) + ...)
//         // since the result will depend on which f is evaluated first, and will yield different results on
//         // different platform/compiler (e.g., clang and gcc yields different results).
//         // The following implementation is uniquely determined.
//         int x = f(6) + player_id * 10 + 2;
//         int y = f(6) + player_id * 10 + 2;
//         return PointF(x, y);
//     };
//     for (PlayerId player_id = 0; player_id < 2; player_id++) {
//         PlayerId id = player_id;
//         // Generate workers (up to three).
//         for (int i = 0; i < 3; i++) {
//             if (f(10) >= 5) {
//                 _CREATE(WORKER, shuffle_loc(gen_loc(player_id), shuffle_lr, shuffle_ud), id);
//             }
//         }
//         if (f(10) >= 8)
//             _CREATE(BARRACKS, shuffle_loc(gen_loc(player_id), shuffle_lr, shuffle_ud), id);
//         if (f(10) >= 5)
//             _CREATE(MELEE_ATTACKER, shuffle_loc(gen_loc(player_id), shuffle_lr, shuffle_ud), id);
//         if (f(10) >= 5)
//             _CREATE(RANGE_ATTACKER, shuffle_loc(gen_loc(player_id), shuffle_lr, shuffle_ud), id);
//     }
//     return true;
// }

#undef _CHANGE_RES
#undef _CREATE
